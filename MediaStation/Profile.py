
from typing import List

from asset_extraction_framework.Asserts import assert_equal
from asset_extraction_framework.File import File

TEXT_ENCODING = 'latin-1'
SECTION_SEPARATOR = '!'

class Profile(File):
    ## Reads a profile from the given location. Profiles contain the names and IDs of all
    ## the assets in this title, along with other data. For newer titles, the asset names
    ## are contained in the Contexts themselves, but for older titles the asset names
    ## are ONLY contained in this file. The extractor can read the asset names in the 
    ## profile to assign better names to the exported assets.
    ## \param[in] - filepath: The filepath of the file, if it exists on the filesystem.
    ##                        Defaults to None if not provided.
    ## \param[in] - stream: A BytesIO-like object that holds the file data, if the file does
    ##                      not exist on the filesystem.
    ## NOTE: It is an error to provide both a filepath and a stream, as the source of the data
    ##       is then ambiguous.
    def __init__(self, filepath: str = None, stream = None):
        # OPEN THE FILE FOR READING.
        # Systems do not have a Media Station header, probably
        # because the only ever have one subfile.
        super().__init__(filepath = filepath, stream = stream)

        self.sections = []
        self.version = Version(self.stream)
        self.contexts = ProfileSection(self.stream, ContextDeclaration)
        self.assets = ProfileSection(self.stream, AssetDeclaration)
        self.file = ProfileSection(self.stream, FileDeclaration)
        self.variables = ProfileSection(self.stream, VariableDeclaration)
        self.resources = ProfileSection(self.stream, ResourceDeclaration)
        self.constants = ProfileSection(self.stream, ConstantDeclaration)

class ProfileSection:
    def __init__(self, stream, profile_entry_class):
        self.records = []
        entry = profile_entry_class(stream)
        end_of_file = (stream.tell() == stream.size())
        stop_reading = entry.end_of_section or end_of_file
        while not stop_reading:
            self.records.append(entry)
            entry = profile_entry_class(stream)
            end_of_file = (stream.tell() == stream.size())
            stop_reading = entry.end_of_section or end_of_file

class ProfileEntry:
    def __init__(self, stream):
        self._raw_entry: List[str] = stream.readline().strip().decode(TEXT_ENCODING).split(' ')
        if self._raw_entry == [SECTION_SEPARATOR]:
            self.end_of_section = True
        else:
            self.end_of_section = False

## Examples:
##  _Version3.4_ _PC_
##  _Version3.3_ _MAC_
class Version(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.version_number: str = self._raw_entry[0]
        # Known strings are "PC" and "MAC".
        self.platform: str = self._raw_entry[1]

## Examples:
##  Context cxt_7x70_Sounds 888886792
##  Screen scr_7x81 889300178
class ContextDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        # Known strings are "Document", "Context", and "Screen".
        self.type: str = self._raw_entry[0]
        self.name: str = self._raw_entry[1]
        self.unk1: int = int(self._raw_entry[2])

## Examples:
##  Root_7x00 109 0
##  img_7x00gg011all_RadioLines 162 8
##  mov_7xb2_MSIBumper 265 104 105 106
class AssetDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.asset_name: str = self._raw_entry[0]
        self.asset_id: int = int(self._raw_entry[1])
        # Movies have more than one chunk, so we will just get the 
        raw_chunk_ids = self._raw_entry[2:]
        self.chunk_ids = [int(raw_chunk_id) for raw_chunk_id in raw_chunk_ids]

    @property
    def has_associated_chunks(self):
        # The presence of no chunks is indicated by a chunk ID of 0.
        if self.chunk_ids[0] == 0:
            return False
        else:
            return True

    ## \return A list of FourCCs associated with this asset, if there are any.
    ##         If there are no chunks for this asset, None is returned.
    ## The FourCC is generated by converting each chunk ID to a one-bsaed, 3-digit 
    ## hex number and appending an "a".
    ## For the three examples provided above, these would be returned:
    ##  Root_7x00 109 0                    -> None
    ##  img_7x00gg011all_RadioLines 162 8  -> ['a008']
    ##  mov_7xb2_MSIBumper 265 104 105 106 -> ['a068', 'a069', 'a6a']
    @property
    def fourccs(self):
        if not self.has_associated_chunks:
            return None 
        
        def create_fourcc(chunk_id: int) -> str:
            if chunk_id > 0xfff:
                raise ValueError(f'Chunk ID {chunk_id} too large to fit in 4-character FourCC.')
            return f'a{chunk_id:03x}'
        return [create_fourcc(chunk_id) for chunk_id in self.chunk_ids]

## Examples:
##  "3664.cxt" 100
##  "113.cxt" 101
##  "436.cxt" 102
class FileDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.filename: str = self._raw_entry[0]
        self.file_id: int = int(self._raw_entry[1])

## Examples:
##  var_6c00_01_CurrentThesaurusImage 100
##  var_6c00_01_CurrentThesaurusSound 101
##  var_6c00_01_CurrentThesaurusMovie 102
class VariableDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.variable_name: str = self._raw_entry[0]
        self.variable_id: int = int(self._raw_entry[1])

## Examples:
##  $Yes 10000
##  $resource 10001
##  $Deactivate 10002
class ResourceDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.resource_name: str = self._raw_entry[0]
        self.resource_id: int = int(self._raw_entry[1])

## Examples:
##  SCREENCOVER_Z -100
##  KNS_COVER_Z -100
##  PLAY_BACKGROUND_PATCH 00:29.00
class ConstantDeclaration(ProfileEntry):
    def __init__(self, stream):
        super().__init__(stream)
        if self.end_of_section:
            return

        self.constant_name: str = self._raw_entry[0]
        self.constant_value = None
        if len(self._raw_entry) > 1:
            self.constant_value = self._raw_entry[1]